\section{Programmation système : processus multiples}
\subsection{Exercice 1}
Concevez et développez une petite application mettant en oeuvre un des services de communication proposé par linux entre un processus parent et un processus enfant.
Le processus enfant devra émettre quelques messages sous forme de texte vers le processus parent, lequel les affichera sur la console. Le mesage exit permettra de terminer l'application.\\
Cette application devra impérativement capturer tous les signaux et les ignorer. Seul un message d'information sera affiché sur la console.\\
Chemin des sources : mulitprocess, ex1_mutliprocess\\
Voici l'output obtenu après lancement du programme:
\begin{lstlisting}
# ./app_a 
In the main process.

In the parent process

In the children process.

Enter a msg to send to the parent : bonojour
bonojour will be written to the parent.
Enter a msg to send to the parent : Received 50 from the children. String is : bonojour
salut
salut will be written to the parent.
Enter a msg to send to the parent : Received 50 from the children. String is : salut
hello
hello will be written to the parent.
Enter a msg to send to the parent : Received 50 from the children. String is : hello
exit
exit will be written to the parent.
Received 50 from the children. String is : exit
#
\end{lstlisting}
Le processus enfant demande à l'utilisateur de tapper quelque chose, qui est ensuite retransmis au parent, qui l'affiche. \\
Ensuite, un second output montre que le SIGINT est géré pour afficher un message en écrivant \textlt{Reveived signal is :} suivi du type de signal. Dans le cas suivant, c'est un ctrl-c qui a été envoyé. 
\begin{lstlisting}
Enter a msg to send to the parent : Received 50 from the children. String is : 
^CReceived signal is : Interrupt
Received signal is : Interrupt
 will be written to the parent.
Enter a msg to send to the parent : Received 50 from the children. String is : 
\end{lstlisting}

\subsection{Exercice 2}
\subsubsection{Quel effet a la commande <<echo \$\$ > ...>> sur les cgroups?}
Par cette commande, on demande aux cgroups de surveiller la tache représentée par le terminal de l'ordroid. Comme le programme que nous lançons depuis la ligne de commande devient le fils du terminal dans lequel il est lancé, on surveille aussi le fils car il est automatiquement affecté à la hiérarchie du parent. 

\subsubsection{Quel est le comportement du sous-système <<memory>> lorsque le quota de mémoire est épuisé? Pourrait-on le modifier? Si oui, comment?}
Le comportement par défaut est de tuer le processus dépassant les limites. Mais il est possible de modifier ce comportement en mettant un \textbf{1} dans <<memory.oom_control>>. Si la modification a été apportée, le processus qui viendrait à dépasser les limites de mémoire se verrait mis en pause.\\

L'output en dessous montre qu'une fois le programme \textif{app_a} lancé, après vingt allocations, il est tué à cause de son excès de consommation mémoire. 
\begin{lstlisting}
# ./app_a 
Ten more megas allocated

Ten more megas allocated

Killed
\end{lstlisting}


\subsubsection{Est-il possible de surveiller/vérifier l'état actuel de la mémoire? Si oui, comment?}
Plusieurs commandes peuvent être utilisées pour visualiser l'état de la mémoire :
\begin{itemize}
\item \textit{free -m}
\item \textit{cat /proc/meminfo}
\end{itemize}
La première produit ce genre d'output:
\begin{lstlisting}
# free -m
              total        used        free      shared  buff/cache   available
Mem:           1990         156        1808           0          24        1813
Swap:             0           0           0
\end{lstlisting}
Tandis que la seconde produit ça :
\begin{lstlisting}
# cat /proc/meminfo 
MemTotal:        2038540 kB
MemFree:         1852220 kB
Buffers:               0 kB
Cached:             5272 kB
SwapCached:            0 kB
Active:             3308 kB
Inactive:           2952 kB
Active(anon):       1012 kB
Inactive(anon):       88 kB
Active(file):       2296 kB
Inactive(file):     2864 kB
Unevictable:           0 kB
Mlocked:               0 kB
HighTotal:       1296384 kB
HighFree:        1147292 kB
LowTotal:         742156 kB
LowFree:          704928 kB
SwapTotal:             0 kB
SwapFree:              0 kB
Dirty:                 0 kB
Writeback:             0 kB
AnonPages:          1000 kB
Mapped:             2084 kB
Shmem:               112 kB
Slab:              20200 kB
SReclaimable:       9264 kB
SUnreclaim:        10936 kB
KernelStack:         840 kB
PageTables:          124 kB
NFS_Unstable:          0 kB
Bounce:                0 kB
WritebackTmp:          0 kB
CommitLimit:     1019268 kB
Committed_AS:       5752 kB
VmallocTotal:     245760 kB
VmallocUsed:       16520 kB
VmallocChunk:     103580 kB
\end{lstlisting}
Si on veut monitorer la consommation de notre application, on peut aussi utiliser Valgrind et l'outil \textit{massif} avec la commande suivante : 
\begin{lstlisting}
valgrind --tool=massif ./app_a
\end{lstlisting}
Le programme s'execute normalement et l'outil de visualisation produit un fichier contenant tout le logging de la mémoire utilisée par l'application. On peut la voir avec la commande :
\begin{lstlisting}
ms_print massif.out.<app_a pid>
\end{lstlisting}
Ce qui produit dans notre cas :
\begin{lstlisting}
--------------------------------------------------------------------------------
Command:            ./app_a
Massif arguments:   (none)
ms_print arguments: massif.out.1695
--------------------------------------------------------------------------------


    MB
47.68^                                                                      :#
     |                                                                   ::@:#
     |                                                               ::::: @:#
     |                                                            ::::: :: @:#
     |                                                        :::::: :: :: @:#
     |                                                     :@@:: ::: :: :: @:#
     |                                                 :::::@ :: ::: :: :: @:#
     |                                              ::::: ::@ :: ::: :: :: @:#
     |                                          :::::: :: ::@ :: ::: :: :: @:#
     |                                       :@@::: :: :: ::@ :: ::: :: :: @:#
     |                                  ::::::@ ::: :: :: ::@ :: ::: :: :: @:#
     |                                ::: :: :@ ::: :: :: ::@ :: ::: :: :: @:#
     |                           :::::::: :: :@ ::: :: :: ::@ :: ::: :: :: @:#
     |                        ::@: :: ::: :: :@ ::: :: :: ::@ :: ::: :: :: @:#
     |                    ::::: @: :: ::: :: :@ ::: :: :: ::@ :: ::: :: :: @:#
     |                 :::: ::: @: :: ::: :: :@ ::: :: :: ::@ :: ::: :: :: @:#
     |             ::::: :: ::: @: :: ::: :: :@ ::: :: :: ::@ :: ::: :: :: @:#
     |          ::@:: :: :: ::: @: :: ::: :: :@ ::: :: :: ::@ :: ::: :: :: @:#
     |       :::: @:: :: :: ::: @: :: ::: :: :@ ::: :: :: ::@ :: ::: :: :: @:#
     |     ::: :: @:: :: :: ::: @: :: ::: :: :@ ::: :: :: ::@ :: ::: :: :: @:#
   0 +----------------------------------------------------------------------->Mi
     0                                                                   13.57

Number of snapshots: 50
 Detailed snapshots: [6, 16, 26, 36, 46, 48 (peak)]

--------------------------------------------------------------------------------
  n        time(i)         total(B)   useful-heap(B) extra-heap(B)    stacks(B)
--------------------------------------------------------------------------------
  0              0                0                0             0            0
  1        425,318        2,000,016        2,000,000            16            0
  2        988,058        4,000,032        4,000,000            32            0
  3      1,550,798        6,000,048        6,000,000            48            0
  4      1,832,168        7,000,056        7,000,000            56            0
  5      2,113,538        8,000,064        8,000,000            64            0
  6      2,394,908        9,000,072        9,000,000            72            0
100.00% (9,000,000B) (heap allocation functions) malloc/new/new[], --alloc-fns, etc.

--------------------------------------------------------------------------------
  n        time(i)         total(B)   useful-heap(B) extra-heap(B)    stacks(B)
--------------------------------------------------------------------------------
  7      2,676,278       10,000,080       10,000,000            80            0
  8      2,957,648       11,000,088       11,000,000            88            0
  9      3,241,862       12,000,096       12,000,000            96            0
 10      3,523,232       13,000,104       13,000,000           104            0
 11      3,804,602       14,000,112       14,000,000           112            0
 12      4,085,972       15,000,120       15,000,000           120            0
 13      4,367,342       16,000,128       16,000,000           128            0
 14      4,648,712       17,000,136       17,000,000           136            0
 15      4,930,082       18,000,144       18,000,000           144            0
 16      5,211,452       19,000,152       19,000,000           152            0
100.00% (19,000,000B) (heap allocation functions) malloc/new/new[], --alloc-fns, etc.

--------------------------------------------------------------------------------
  n        time(i)         total(B)   useful-heap(B) extra-heap(B)    stacks(B)
--------------------------------------------------------------------------------
 17      5,492,822       20,000,160       20,000,000           160            0
 18      5,774,192       21,000,168       21,000,000           168            0
 19      6,056,031       22,000,176       22,000,000           176            0
 20      6,337,401       23,000,184       23,000,000           184            0
 21      6,618,771       24,000,192       24,000,000           192            0
 22      6,900,141       25,000,200       25,000,000           200            0
 23      7,181,511       26,000,208       26,000,000           208            0
 24      7,462,881       27,000,216       27,000,000           216            0
 25      7,744,251       28,000,224       28,000,000           224            0
 26      8,025,621       29,000,232       29,000,000           232            0
100.00% (29,000,000B) (heap allocation functions) malloc/new/new[], --alloc-fns, etc.

--------------------------------------------------------------------------------
  n        time(i)         total(B)   useful-heap(B) extra-heap(B)    stacks(B)
--------------------------------------------------------------------------------
 27      8,306,991       30,000,240       30,000,000           240            0
 28      8,588,361       31,000,248       31,000,000           248            0
 29      8,870,200       32,000,256       32,000,000           256            0
 30      9,151,570       33,000,264       33,000,000           264            0
 31      9,432,940       34,000,272       34,000,000           272            0
 32      9,714,310       35,000,280       35,000,000           280            0
 33      9,995,680       36,000,288       36,000,000           288            0
 34     10,277,050       37,000,296       37,000,000           296            0
 35     10,558,420       38,000,304       38,000,000           304            0
 36     10,839,790       39,000,312       39,000,000           312            0
100.00% (39,000,000B) (heap allocation functions) malloc/new/new[], --alloc-fns, etc.

--------------------------------------------------------------------------------
  n        time(i)         total(B)   useful-heap(B) extra-heap(B)    stacks(B)
--------------------------------------------------------------------------------
 37     11,121,160       40,000,320       40,000,000           320            0
 38     11,402,530       41,000,328       41,000,000           328            0
 39     11,684,369       42,000,336       42,000,000           336            0
 40     11,965,739       43,000,344       43,000,000           344            0
 41     12,247,109       44,000,352       44,000,000           352            0
 42     12,528,479       45,000,360       45,000,000           360            0
 43     12,809,849       46,000,368       46,000,000           368            0
 44     13,091,219       47,000,376       47,000,000           376            0
 45     13,372,589       48,000,384       48,000,000           384            0
 46     13,653,959       49,000,392       49,000,000           392            0
100.00% (49,000,000B) (heap allocation functions) malloc/new/new[], --alloc-fns, etc.

--------------------------------------------------------------------------------
  n        time(i)         total(B)   useful-heap(B) extra-heap(B)    stacks(B)
--------------------------------------------------------------------------------
 47     13,935,329       50,000,400       50,000,000           400            0
 48     14,219,956       50,000,400       50,000,000           400            0
100.00% (50,000,000B) (heap allocation functions) malloc/new/new[], --alloc-fns, etc.

--------------------------------------------------------------------------------
  n        time(i)         total(B)   useful-heap(B) extra-heap(B)    stacks(B)
--------------------------------------------------------------------------------
 49     14,225,284        2,000,016        2,000,000            16            0
\end{lstlisting}
Pour nous rassurer, avec la commande et l'output suivant, on constate quand même que la mémoire a bien été libérée:
\begin{lstlisting}
# valgrind ./app_a 
==1701== Memcheck, a memory error detector
==1701== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
==1701== Using Valgrind-3.10.0 and LibVEX; rerun with -h for copyright info
==1701== Command: ./app_a
==1701== 
Ten more megas allocated

Ten more megas allocated

Ten more megas allocated

Ten more megas allocated

Press enter to continue...


Ten more megas freed

Ten more megas freed

Ten more megas freed

Ten more megas freed

Ten more megas freed

==1701== 
==1701== HEAP SUMMARY:
==1701==     in use at exit: 0 bytes in 0 blocks
==1701==   total heap usage: 50 allocs, 50 frees, 50,000,000 bytes allocated
==1701== 
==1701== All heap blocks were freed -- no leaks are possible
==1701== 
==1701== For counts of detected and suppressed errors, rerun with: -v
==1701== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\end{lstlisting}
Pour les derniers outputs, la limite d'allocation mémoire a été élevée à 100MB. Aucune solution n'a été trouvée autrement pour monitorer la mémoire du processus durant son exécution avec le contrôle de la mémoire. Valgrind est autant tué que l'application, sinon.